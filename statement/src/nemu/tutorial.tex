\begin{Solution}{NJU Emulator}

\begin{frame}{\ProblemName}

\small Problem Author: Chen Shaoyuan, Problem Developer: Chen Shaoyuan \par \vspace{0.3cm}

\small Submissions: Div.1 (?+?)/(?+?), Div.2 (?+?)/(?+?)  \par \vspace{0.5cm}

Given a specification of ISA of a stack machine, construct a program that generate given integer $N$. The number of instruction should be no more than 200 for Div.2, or 60 for Div.1.

\pause

For Div.2, we may construct the number bitwise. We may use \texttt{add 0} to left shift the integer, and use another \texttt{add} to increment the integer, if the current bit should be set.

\end{frame}

\begin{frame}{\ProblemName}

For Div.1, the limit is much more stringent. We can use a technique called `Method of Four Russians', named after the cardinality and nationality of its inventors. 

\pause

The main idea of this technique is to devide the problem into several small subproblems, precompute the solution to each possible small subproblem, and then combine these solutions. This technique can usually be used to accelerate original algorithm by a factor of $O(\log n)$.

\end{frame}

\begin{frame}{\ProblemName}

Now back to our problem. Instead of constructing the number bitwise, we may construct the number in some other base $b$, by preprocessing the numbers from $1$ to $b$. The target number can be constructed digit-wise in multiply-add fashion. 

\pause

For a $K$-bit integer, if we construct it in base $b$, the number of instructions needed is $O(2^b + K / \log b)$. Take $b = \Theta(\log K - \log \log K)$, the number of instructions is $O(K / \log K)$. Compared with the original $O(K)$ construction, this is an improvement of an order of magnitude if $K$ is large!

\pause

Actually, the upper bound can be further optimized by adopting some tricky techniques, which is of course not required here.

\end{frame}

\end{Solution}
